var documenterSearchIndex = {"docs":
[{"location":"#FourierTransforms.jl","page":"FourierTransforms.jl","title":"FourierTransforms.jl","text":"","category":"section"},{"location":"","page":"FourierTransforms.jl","title":"FourierTransforms.jl","text":"Fast Fourier Transforms implemented in pure Julia.","category":"page"},{"location":"","page":"FourierTransforms.jl","title":"FourierTransforms.jl","text":"The main goal of this package is to calculate Fourier Transforms for all Julia array types and size and element types with reasonable efficiency (i.e. with O(n log n) operations and O(n) storage). This should also make this package differentiable. You can expect special-purpose packages that specialize on array or element types such as FFTW.jl to achieve a higher performance.","category":"page"},{"location":"","page":"FourierTransforms.jl","title":"FourierTransforms.jl","text":"Currently, not all input lengths are supported. Powers of 2 and products of powers small primes work fine. However, each prime factor of the input length is handled via a direct Fourier transform, and this becomes inefficient if there are large prime factors.","category":"page"},{"location":"","page":"FourierTransforms.jl","title":"FourierTransforms.jl","text":"Most functions come in two versions, one that mutates its arguments and one that allocates its output.","category":"page"},{"location":"#Example","page":"FourierTransforms.jl","title":"Example","text":"","category":"section"},{"location":"","page":"FourierTransforms.jl","title":"FourierTransforms.jl","text":"The Fourier Transform is a linear operator:","category":"page"},{"location":"","page":"FourierTransforms.jl","title":"FourierTransforms.jl","text":"using FourierTransforms\nRandom.seed!(100)\n\nT = Complex{BigFloat}\nN = 768\n\n# Create some data\nx = T.(randn(Complex{Float64}, N));\ny = T.(randn(Complex{Float64}, N));\nα = T.(randn(Complex{Float64}));\n\n# Calculate a linear combination\nz = α * x + y;\n\n# Evaluate the Fourier Transform\nX = fft(x);\nY = fft(y);\nZ = fft(z);\n\n# Check linearity\nprintln(\"Error: \", maximum(abs.(α * X + Y - Z)))","category":"page"},{"location":"#Fourier-Transforms","page":"FourierTransforms.jl","title":"Fourier Transforms","text":"","category":"section"},{"location":"","page":"FourierTransforms.jl","title":"FourierTransforms.jl","text":"The functions with dh in their names use the Driscoll & Healy quadrature points. With L = lmax+1 modes there are nphi * ntheta quadrature points on the sphere, with nphi = 2L-1 and ntheta = 2L. The points are equispaced in the angles theta (latitude) and phi (longitude), and they straddle (avoid) the poles.","category":"page"},{"location":"","page":"FourierTransforms.jl","title":"FourierTransforms.jl","text":"fft!\nfft\ninv_fft!\ninv_fft","category":"page"},{"location":"#FourierTransforms.fft!","page":"FourierTransforms.jl","title":"FourierTransforms.fft!","text":"fft!(X::AbstractVector, x::AbstractVector)\n\nCalculate the Fourier transform of x and store it into X. x is not modified. Both vectors must have the same length and must have complex element types.\n\nSee also: fft, inv_fft!.\n\n\n\n\n\n","category":"function"},{"location":"#FourierTransforms.fft","page":"FourierTransforms.jl","title":"FourierTransforms.fft","text":"X = fft(x::AbstractVector)\nX::AbstractVector\n\nCalculate the Fourier transform of x and return it in a newly allocate vector. x is not modified. The element type of x must be a complex number type.\n\nSee also: inv_fft, fft!.\n\n\n\n\n\n","category":"function"},{"location":"#FourierTransforms.inv_fft!","page":"FourierTransforms.jl","title":"FourierTransforms.inv_fft!","text":"inv_fft!(x::AbstractVector, X::AbstractVector)\n\nCalculate the inverse Fourier transform of X and store it into x. X is not modified. Both vectors must have the same length and must have complex element types.\n\nSee also: inv_fft, fft!.\n\n\n\n\n\n","category":"function"},{"location":"#FourierTransforms.inv_fft","page":"FourierTransforms.jl","title":"FourierTransforms.inv_fft","text":"x = inv_fft(X::AbstractVector)\nx::AbstractVector\n\nCalculate the inverse Fourier transform of X and return it in a newly allocate vector. X is not modified. The element type of X must be a complex number type.\n\nSee also: fft, inv_fft!.\n\n\n\n\n\n","category":"function"}]
}
